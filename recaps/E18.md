# E18

## REST

une norme qui prÃ©cise la faÃ§on d'organiser notre API cotÃ© client (route + methods HTTP)

[doc](https://restfulapi.net/resource-naming/)

## Challenge

[challenge](../Challenge%20API.md)

CRUD : vient des opÃ©rations en base de donnÃ©es

* Create : INSERT INTO
* Read : SELECT
* Update : UPDATE
* Delete : DELETE

Le hic c'est que en mode API on a deux routes READ :

1. /api/movies => la collection
2. /api/movies/{id} => un Ã©lÃ©ment

BREAD : nous propose un autre nommage plus adaptÃ©

* Browse : read collection
* Read : read un Ã©lÃ©ment
* Edit : modifier un Ã©lÃ©ment
* Add : ajouter un Ã©lÃ©ment
* Delete : supprimer un Ã©lÃ©ment

### Erreur j'ai pas la classe repository d'une entitÃ©

Il faut rajouter l'annotation de la classe repository pour qu'elle soit regÃ©nÃ©rÃ©e.

```php
/**
 * @ORM\Entity
 */
/**
 * @ORM\Entity(repositoryClass="App\Repository\GenreRepository")
 */
```

il ne reste plus qu'a faire un regenerate

```bash
bin/console make:ent --regenerate

 This command will generate any missing methods (e.g. getters & setters) for a class or   
 all classes in a namespace.                                                              
                                                                                          
 To overwrite any existing methods, re-run this command with the --overwrite flag         

 Enter a class or namespace to regenerate [App\Entity]:
 > App\Entity\Genre

 created: src/Repository/GenreRepository.php
 no change: src/Entity/Genre.php

           
  Success! 
           
```

[doc](https://ourcodeworld.com/articles/read/1314/how-to-automatically-generate-the-doctrine-repository-class-of-an-entity-in-symfony-5)

## POST, PUT, PATCH, DELETE

### DELETE

route : `HTTP DELETE` `/api/{ressource}/{id}`

controller : remove($id)

on sait dÃ©jÃ  faire, les informations necessaire Ã  la suppression nous sont fournit dans l'URL (id)

### POST : rÃ©flexion

exemple : crÃ©ation d'un genre

route : `HTTP POST` `/api/{ressource}`

controller: new ressource(), + les valeurs obligatoires ....

on est obligÃ© de demander au client/front de nous donner les infos

Sous quelle forme il va nous les donner ? JSON

On va rÃ©cupÃ©rer ce JSON via $request

### POST et deserialize

Quand on est en mode "API", si on permet la crÃ©ation avec la route `POST`, on doit s'attendre Ã  recevoir du JSON.

Simple en PHP, on `deserialize` le json que l'on reÃ§oit et ðŸ’¥ on a un objet PHP.

On injecte la requÃ¨te HTTP dans notre fonction pour en rÃ©cupÃ©rer le contenu

```php
use Symfony\Component\HttpFoundation\Request;
public function createItem(Request $request)
{
    // RÃ©cupÃ©rer le contenu JSON
    $jsonContent = $request->getContent();
```

Comme prÃ©vu on `deserialize`, c'est Ã  dire que l'on transforme le JSON en Objet en prÃ©cisant l'entitÃ© que l'on veux.

On n'oublie pas d'injecter le Serializer de Symfony

```php
use Symfony\Component\Serializer\SerializerInterface;
public function createItem(Request $request, SerializerInterface $serializer)
{
    // RÃ©cupÃ©rer le contenu JSON
    $jsonContent = $request->getContent();
    // DÃ©sÃ©rialiser (convertir) le JSON en entitÃ© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
```

ðŸŽ‰ trop facile, on donnes Ã§a Ã  Doctrine pour qu'il le mettes en BDD et c'est bon ðŸ’ª

```php
use Doctrine\ORM\EntityManagerInterface;
public function createItem(Request $request, SerializerInterface $serializer, EntityManagerInterface $doctrine)
{
    // RÃ©cupÃ©rer le contenu JSON
    $jsonContent = $request->getContent();
    // DÃ©sÃ©rialiser (convertir) le JSON en entitÃ© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // On sauvegarde l'entitÃ©
    $doctrine->persist($movie);
    $doctrine->flush();
```

ðŸ˜… `SQLSTATE[xxxx] xxxx cannot be null`

Comment Ã§a MySQL n'est pas content ? ðŸ‘¿

Ben oui, il manque des donnÃ©es, on va demander Ã  Symfony de nous valider tout Ã§a ðŸ’ª et surtout de nous dire ce qui coince.
Comme Ã§a on prÃ©vient notre utilisateur en front et on lui dÃ©crit les problÃ¨mes pour qu'il s'adapte et qu'il nous envoie les bonnes donnÃ©es.

```php
use Symfony\Component\Validator\Validator\ValidatorInterface;
public function createItem(Request $request, SerializerInterface $serializer, EntityManagerInterface $doctrine, ValidatorInterface $validator)
{
    // RÃ©cupÃ©rer le contenu JSON
    $jsonContent = $request->getContent();
    // DÃ©sÃ©rialiser (convertir) le JSON en entitÃ© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // Valider l'entitÃ©
    // @link : https://symfony.com/doc/current/validation.html#using-the-validator-service
    $errors = $validator->validate($movie);
    // Y'a-t-il des erreurs ?
    if (count($errors) > 0) {
        // @todo Retourner des erreurs de validation propres
        return $this->json($errors, Response::HTTP_UNPROCESSABLE_ENTITY);
    }
    // On sauvegarde l'entitÃ©
    $doctrine->persist($movie);
    $doctrine->flush();

    // on renvoit un code 201 et l'objet crÃ©e
    return $this->json($movie, Response::HTTP_CREATED);
```

ðŸŽ‰ Tout fonctionne Ã  merveille, on valide que tout est bon

ðŸ’¥ notre utilisateur nous envoit une chaine de caractÃ¨res qui n'est pas du JSON.

le serializer n'arrive donc pas Ã  deserializer, normal on lui donne un truc tout cassÃ©.

On doit donc attraper cette erreur, pour cela on utilise le `try{} catch(){}`

```php
try // essaye de faire d'Ã©xÃ©cuter ce code
{
    /** @var Movie $newMovie */
    $newMovie = $serializerInterface->deserialize($jsonContent, Movie::class, 'json');
}
catch(Exception $e) // si tu n'y arrives pas
{
    // j'arrive ici si une exception a Ã©tÃ© lancÃ©e
    // dans notre cas si le json fourni n'est pas bien Ã©crit : en fait c'est pas du json
    return $this->json("Le JSON est mal formÃ©", Response::HTTP_BAD_REQUEST);
}
```

Quand on a fini la crÃ©ation on redirige notre utilisateur sur la bonne route.
Pour cela on utilise l'entÃªte HTTP : `Location`

```php
return $this->json(
        $movie,
        // je prÃ©cise que tout est OK de mon cotÃ© en prÃ©cisant que la crÃ©ation c'est bien passÃ©
        // 201
        Response::HTTP_CREATED,
        // REST demande un header Location + URL de la ressource
        [
            // Nom de l'en-tÃªte + URL
            'Location' => $this->generateUrl('api_movies_read', ['id' => $movie->getId()])
        ]
        // comme on redirige, on n'a pas besoin de spÃ©cifier des groupes de sÃ©rialisation
    );
```

### PUT, PATCH : update

le sujet de PUT ou PATCH est encore dÃ©battu, et n'en finira peut Ãªtre jamais.

Pour nous c'est la mÃªme chose, un update.

route :  `HTTP PUT` `/api/{ressource}/{id}`

On va rÃ©pÃ©ter la mÃªme structure que le POST, sauf:

* pour la partie BDD oÃ¹ il n'y aura que le flush()
* la route oÃ¹ on a un objet existant

## sÃ©curiser notre API

[LexikJWTAuthenticationBundle](https://github.com/lexik/LexikJWTAuthenticationBundle)

```bash
composer require lexik/jwt-authentication-bundle
```

```bash
bin/console lexik:jwt:generate-keypair

                                                                                                              
 [OK] Done!                                                                                                   
```

avec cette commande, Lexik nous gÃ©nÃ¨re les clÃ©s de chiffrement. Sans ces clÃ©s, Lexik ne fonctionne pas.

Ensuite il faut paramÃ©trer notre application, sauf que `composer` l'a dÃ©jÃ  fait dans le fichier .env, plus rien Ã  faire de ce cotÃ© lÃ .

petite astuce pendant le dev, changer le paramÃ©trage du token_ttl Ã  18h.
lexik_jwt_authetification.yaml

```yaml
lexik_jwt_authentication:
    secret_key: '%env(resolve:JWT_SECRET_KEY)%'
    public_key: '%env(resolve:JWT_PUBLIC_KEY)%'
    pass_phrase: '%env(JWT_PASSPHRASE)%'
    token_ttl: 64800 # 18h in seconds, default is 3600
```

## Annexes

rÃ¨gles de codage: [PSR-12](https://www.php-fig.org/psr/psr-12/)

dans VSCode, avec l'extention

```text
NomÂ : php cs fixer
IDÂ : junstyle.php-cs-fixer
DescriptionÂ : PHP CS Fixer extension for VS Code, php formatter, php code beautify tool, format html
VersionÂ : 0.2.12
Serveur de publicationÂ : junstyle
Lien de la Place de marchÃ© pour VSÂ : https://marketplace.visualstudio.com/items?itemName=junstyle.php-cs-fixer
```

`F1` > `php-cs fixer: fix this file`



Pour rÃ©cuperer le token de connexion dans le terminal => curl -X POST -H "Content-Type: application/json" http://localhost:8080/api/login_check -d '{"username":"admin@admin.com","password":"admin1"}'
